## HashMap面试题

### 1. HashMap 为何容量是2的n次幂

- &运算速度快，至少比%取模运算快

- 能保证索引值肯定在HashMap的容量大小范围内

- (n - 1) & hash的值是均匀分布的，可以减少hash冲突

### 2. 什么是哈希碰撞，为什么会发生哈希碰撞

不同的关键字通过哈希函数得出相同的哈希地址

原因是hash函数只保证关键字的键值对应一个hash值，不保证hash值对应一个唯一一个键值，也就是hash函数是一个一对多的关系

### 3. Hash 函数的设计原则

1.  尽量减少冲突

2. 运算快速

3. hash计算的地址会随机分布在整个地址空间

### 4. 常见的hash函数

1.  除留余数法

2.  直接定址法

### 5. 如何避免hash冲突

1. 设计更合理的hash函数

2. 调节合适的负载因子
   
   负载因子过小，则会频繁扩容，负载因子过大，则容易产生冲突

### 6. 如何解决hash冲突

1. 线性探测

2. 二次探测

3. 链式地址法

### 7. hashMap的特性

1.  快速存储（链式地址法的时间复杂度，链表长度，红黑树logn）

2.  线程不安全

3. 无序存储

### 8. hashMap的底层存储

1.  Java8采用链式地址法和红黑树

### 9. 转换条件

1.  链式地址法转红黑树：

    数组 arr[i] 处存放的链表长度大于8；数组长度大于64。

    满足以上两个条件，数组 arr[i] 处的链表将自动转化为红黑树，其他位置如 arr[i+1] 处的数组元素仍为链表，不受影响，数组长度小于64是树化。

    2. 红黑树转链式地址：

- 第一 树内节点数小于等于6
- 第二：根节点为空，根节点的左右子树为空，根节点的左子树的左子树为空

### 10. 我们调用一个 new HashMap<>(),无参的构造方法创建map对象，会发生什么？

没有进行初始化数组空间，只是指定了 负载因子为默认负载因子 0.75f

### 11. 那么什么时候初始化数组空间分配内存呢？

当我们给这个哈希表put一个元素的时候，会初始化一个容量为 16的数组空间。

### 12. 为什么HashMap 中数组的初始化容量必须是 2的n次幂呢？

我们在HashMap中 添加一个元素的时候，是根据key的哈希值确定在数组中的 位置。

HashMap 为了存取更加高效，就要尽量减少碰撞，就是把数组分配均匀，每个链表的长度大致相同，为了实现这个功能，就是看具体的哈希表中存储数据到链表中的算法

这个算法就是取模，计算数组下标索引(hash % length) 只不过位运算的效率比较高，源码中是 (hash & length-1 )，但是如果先要实现 hash& lenth-1 等同于 hash % length 的前提条件就是 length 必须是 2 的n次幂。

### 13. 指定参数调整

如果给一个参数，那么指定了 capacity的大小，还指定了 负载因子的大小为 默认值 0.75f

他底层主要是调用了haspMap本身的带有两个参数的构造方法

如果这个参数小于0，那么抛异常，打印 非法的初始化容量

如果这个参数大于 Max_capacity 数组最大容量2^30 ，那么数组的容量就是2^30

如果指定的数组容量不是2的幂次方，那么在构造方法中就会调用一个 tableSizeFor() 方法返回一个大于指定容量参数且最接近参数的2的整次幂的一个数，

比如说我们指定数组容量为7 ，那么初始化数组容量大小为 8.



### 14. resize()方法

现获得原数组的长度，阈值，然后都增大二倍得到新数组的长度和 阈值

然后我们 拿新数组的长度new一个空的新数组

然后遍历原数组中的每一个元素，重新计算元素的hash值，然后与新数组取余获得索引，按照索引把元素放到新数组的对应位置

resize里面遍历原数组每个元素计算hash是很消耗性能的，所以呢hashmap 底层不会再去重新用一个hash函数算每一个元素key的hash值，他是通过计算hash & oldCap 计算，如果是0，那么在新数组中索引不变，如果是1 ，那么在新数组中索引时 老索引+原数组长度。

如果面试官没明白啥意思 ，那个具体的数字来算一遍，就啥都明白了。
